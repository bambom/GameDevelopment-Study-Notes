《GameProject》 主要是集中lib 运行时库

《GameUnity》 主要集中Unity中和引擎直接相关的库：
比如 BakeAnimator ,ShaderMap ，阴影，和lib库对应的unity编辑器的库。

### [基于UGUI的UI库]()
  
  * [1、UGUI的动画库解决方案](#01)
  * [2、ScrollRect滑动裁切算法](#02)
  * [3、任意曲线的循环滑动条](#03)
  * [4、UI适配](#04)
  * [5、对页面管理器的思考](#05)
    * [UI系统生命周期的封装，mvc和通用设计，如何在框架和效率上做出取舍]()
    * [系统层面的池的封装]()
  
* * *

### [mmo-业务lib]()

  * [资源加载管理系统](#06)
    * [具体需求分析]()
    * [设计缘由(为什么这么设计)]()
    * [详细设计和架构]()
    * [容易出现的问题]()

* * *

 * [资源更新,增量更新的思考]()
    * [对资源的类型细分]()
    * [从分类打包到运行时设计,(简化开发流程)]()
    * [抽象的设计，好的代码流程和好的可维护性]()
  
* * *

  * [网络系统](#07)
    * [Ipv4|Ipv6]()
    * [网络层方案TCP、UDP、KCP概略]()
    * [网络层的逻辑和表现抽象]()
    * [帧同步]()
    
* * *

  * [寻路系统](#08)
    * [系统背景和需求分析(有什么需求，要做什么，外挂、同步)]()
    * [系统设计缘由(为什么这么做？)开发的技术基础(A*star、服务器同同步预测)]()
    * [设计细节(怎么做)]()
        1. [A*start的详细原理]()
        2. [编辑器工具设计]()
        3. [运行时代码抽象设计]()
        4. [和服务器同步的协议设计]()
        5. [预测机制，防止服务器拉拽]()
        6. [可能出现的问题，比如卡死情况]()
    * [改进与思考(改进和不足)]()
        1. [分层寻路]()
        2. [动态壁障]()

* * *

  * [关卡系统](#09)
    * [系统背景、需求分析(what? 什么效果) 大概怎么做 做出什么样]()
    * [why，这套系统为什么这么设计，从用户体验的角度，简化工作痛点的角度]()
      * 设计决策(参考[字节码模式](https://gpp.tkchu.me/bytecode.html#栈式机器)分析)
        * 访问堆栈(虚拟机，内存访问)
        * 指令类型
        * 数值的表示
        * 字节码生成
    * [详细设计(怎么设计？)]()
        1. [运行时设计,文件配置，任何系统使用的可拓展性，比如管卡活动，剧情，任务等]()
        2. [编辑器设计]()
    * [引申和思考(存在过哪些问题，还有哪些问题没有解决，该如何去优化这些工作流程，给用户最大的效率和便捷性)]()

* * *

  * [剧情系统](#10)
    * [剧情对话Dialog]()

  * [任务系统](#11)

* * *

  * [引导系统]()
    * [系统背景、业务需求分析(需求what？达到什么效果)]()
    * [系统设计理由(为什要这么设计)]()
    * [详细设计(怎么做？)]()
         1. [配置设计,和服务器通讯设计]()
         2. [编辑器设计、和运行时设计]()
* * * 
  
  * [关于系统架构(场景、实体、AI、战场逻辑框架的深度思考)](#12)
    * [关于场景逻辑流程该如何组织代码、布局(关卡、公会战、自走棋、SLG)]()
    * [和服务器同步的几种方式(关卡、公会战、自走棋、SLG)]()
   
* * *
  * [关于语音社交](#13)
* * *
  * [自动化Jenkiens](#14)
    
* * *
  * [关于机型适配](#15)
* * *
  * [关于优化](#16)
  
* * *
 * [GC、语言](#17)
  GC,数据结构，字典，List. 什么情况使用什么数据结构。 一个操作有什么消耗。
  [垃圾回收](https://connect.unity.com/doc/Manual/UnderstandingAutomaticMemoryManagement)


<h3 id = "#002">事件系统</h3>

   一个事件系统的编写很简单核心是对id和delegate集合的维护。但是如何让事件系统在各个模块中好用，使得代码简洁，可维护，却是需要仔细思考的问题。 事件系统最主要的作用在于减少各个块间的耦合。 就是实体系统来说，实体运行的过程中技能，动作，模型等各个时间不用组件功能间的调用，在actor本身进行定封装的话，可以有效的减少实体模块的复杂度，让代码更加的简洁明了易于维护。 全局的GameEvent事件，最好不要将所有的事件写在一起，能按模块划分，根据不用的业务进行处理是比较可行的。 ，比如一种做法是，每个模块的事件消息定义一个接口，然后GameEvent将接口注册到这个接口实例上。



<h3 id = "#003">UI模块</h3>
   首先MVC好还是一把梭好。MVC稍微复杂，但是可以如何去简化代码

<h3 id = "#006">资源管理系统</h3>
1. 期望的目标系统
   期望对资源管理系统的最终

<h3 id = "#007">关于包流程上的一些东西</h3>
   IOS出包的时候经常会卡流程，搞到晚上很伤。
   要出包前确定 1、功能的完整性，

<h3 id="#09">关卡系统</h3>

   * 关卡中需要添加人物创建销毁的相关的逻辑。不然关卡剧情比较复杂，一次性创建，有点伤
   * 支持运行时编辑，在调试和设计的时候更加便捷
   * 关于场景模型的效果和逻辑的事件，可以分开处理。 场景的一些表现触发标识，比如桥的断裂和逻辑上的处理 分别配置
   * 目前的这些配置和设计还是属于黑盒，不够灵活，和方便的进行逻辑的变更。需要提供更加灵活的设计方式。 就命令上而言。
   * 需要提供更加方便的排错方式。从产品的体验方式上看
   * 最新的Unity版本中的Timeline 和 cameramecine 可以合成到里面

<br><br>

* * *
    * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* * *
<br><br>

<h3 id="#12">架构-之实体组织逻辑</h3>
  ## 基于MVC的代码
     基于状态的代码总是比较难以令人理解。逻辑体(Unit)、行为体(UnitBehaviour)、状态体（FSM）、显示实体（Entity）是常见的mvc形式的代码组织方式。
     逻辑体是最直接的控制体，一般是服务器操控和本地的实体管理对象，m层；行为体是作为衔接Enity(V层)和unit的中间控制层，也就是ctr层。 状态体则是unit的状态管理，主要是对状态的维护，其逻辑表现还是通过对behaviour的调用。

  ## 关于代码的可维护性
    代码的简洁性，可视性，逻辑是否清晰，直接影响代码的维护。像OP的PageManager就十分难以理解。而SLG的代码结构就十分清晰。
    每行代码的编写都应该仔细思考

  ##针对于自走棋架构的重构
    用了什么设计模式，每种模式的细节优缺点，能够像书那样给人讲明白前因后果。 如何封装简化代码。 如何抽离输入和逻辑。
    自走棋里面重连的问题出现在 重连，重新登录是没问题的。是重连和从新登陆的流程问题。 另外如果是战斗状态的时候，服务器直接把消息发过来这时候客户端会来不及接收。这时候服务器是判断客户端已经在线状态了，但是客户端还没有处理。就有问题了。
    流程性的通行，应该和服务器有来回握手确认，进入游戏，客户端加载完资源，进入流程，然后告诉服务器我已经准备完毕，在让服务器吧相关的数据同步过来。 然后客户端进行创建处理。
    不然服务器一次性把数据发过来

   * OP中最令人诟病的就是极度糟糕的实体实现，完全的继承拓展的添加新的功能，既没有使用组件模式的方式分离耦合开放拓展，也没有通过委托类(状态模式、类型对象、行为树等)的方式去定义新的行为。
   * 优先使用组合而非继承是面向对象设计中的共识，如何组织策划简洁优雅且灵活的代码，是代码简洁之道的终极目标。
   * 通常实体的组织分 数据(数值数据，状态数据，world数据等)，渲染（模型加载，状态切换），物理(移动，冲击等等)，行为（定义实体的逻辑行为），这些可以通过组件模式将逻辑组件化，行为可以使用委托类* 进行拆分，比如使用状态设计和行为树将代码进行解耦和开放拓展。
   * 行为模式： 定义好world实体后，如果组织实体上层的行为逻辑。 类型对象(定义行为的类别)、子类沙盒(定义行为的安全原语)、字节码(将行为从代码分离，放入数据文件)
   * 关卡驱动系统就是一个很具特征性的行为模式。相当于在游戏系统中创建了一个小系统(或者说是脚本语言)
  
   * 关于字节码模式
     * 其核心是将行为编码成独立于游戏核心的沙盒环境中，将其行为抽象到数据当中表示。 与之实现的方式有多种，解释器模式，事件驱动的行为设计方式等。 而通常来说抽象出一个高层的行为系统时，还需要做编辑器去定义行为的。从抽象行为的系统，到定义行为的编辑，到行为数据的解析，再到运行时的处理，这是一套完整的设计。[关于字节码](https://gpp.tkchu.me/bytecode.html#栈式机器)
  
   * 关于子类沙箱模式
     * 在基类中定义原子操作，从而减少子类的间的耦合的代码。 
     * 定义的原子操作，如果使得子类越来越大的话，就需要对基类进行拆分，构造辅助类或组件模式。
     * 子类对基类状态的访问，是封装沙盒方法，还是直接对外部调用，如何构造简洁的代码需要按状斟酌。
     * 状态的初始化，通常是建造，装配的过程。
     * 这个模式也可以说是拓展的外观者模式。
  
  * 关于类型对象


  * 简单说下小小的事件系统，以及，如何对事件系统组织代码和设计。以达到最好的架构和简洁代码。 例如在实体系统中嵌入只属于实体的事件分发系统。

  各个系统的逻辑划分都可以分为几个大块： 输入模块、执行模块、执行操作的原子模块
  对于关卡事件系统来说： 输入模块是每个Story驱动，Story定义了触发条件和执行，触发条件就是整体的输入驱动， cell 定义的各个原子操作就是底层架构执行，包含了场景实体的逻辑操作， 定义各种行为的操作。

  对于自走棋来说：整体的输入驱动来源于，服务器的数据操作，和玩家自己的输入操作，驱动逻辑的运行。 原子操作就是每个英雄实体。 对英雄实体组织逻辑操作的是玩家的输入交互系统， 和整个游戏的流程控制系统。  控制系统一般需要单独拆分出来作为单独的管理。 流程控制系统可以使用单例管理器或者其他代码组织方式合理的进行代码组织

  对于战斗系统来说： 回合制的战斗主要是分战斗回合的流程控制， 流程控制用来控制英雄实体的行为释放， 行为释放等技能系统是封装在实体里面的。