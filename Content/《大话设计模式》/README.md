# 《大话设计模式》全书概览

  ![](Media/1.png)
<br>
<br>

# 目录与说明

* [零、模式构成](#00)
* [一、创建型模式](#01)
    * [1、单例模式](#1)
    * [2、工厂方法](#2)
    * [3、抽象工厂方法](#3)
    * [4、建造者模式](#4)
    * [5、原型模式](#5)
* [二、结构型模式](#02)
    * [6、适配器模式](#6)
    * [7、装饰模式](#7)
    * [8、桥接模式](#8)
    * [9、组合模式](#9)
    * [10、享元模式](#10)
    * [11、代理模式](#11)
    * [12、外观模式](#12)
* [三、行为型模式(Part1)](#03)
    * [13、观察者模式](#13)
    * [14、模版方法模式](#14)
    * [15、命令模式](#15)
    * [16、状态模式](#16)
    * [17、职责链模式](#17)
* [四、行为型模式(Part2)](#04)
    * [18、解释器模式](#18)
    * [19、中介者模式](#19)
    * [20、访问者模式](#20)
    * [21、策略模式](#21)
    * [22、备忘录模式](#22)
    * [23、迭代器模式](#23)
<h1 id='00'>零、模式构成</h1>

通过从三方面进行介绍：

- 要点
- 使用场合
- 引申与参考

- 抽象、封装、继承、多态，是设计模式实现的基本思想和工具。

- 单一职责、开放封闭原则、依赖倒置原则、里氏代换原则、合成聚合复用原则、迪米特法则，是设计模式要达到的最终目的。
  

[C#练习工程-Gitee仓库地址](https://gitee.com/bambom/shejimoshi)
 <br>

正文：
  <br>
  <br>

<h1 id="01">一、创建型模式</h1>

- 内聚性：描述的是一个例程内部组成部分之间相互联系的紧密程度。 耦合性：描述的是一个例程与其他例程之间联系的紧密程度。 软件开发的目标应该是创建这样的例程： 内部完整(高内聚)，与其他例程之间联系是小巧、直接、可见、灵活的(松耦合)。
  
- 创建型模式隐藏了这些类的实例是如何被创建和放在一起的，整个系统关于这些对象所知道的是有抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建的类、类是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。

- 创建型模式抽象了实例化的过程。他们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建性模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的在运行时指定。
  
- 当一个系统应该独立于他的产品创建、构成、和表示时，应该考虑用创建型模式。

<h2 id="1">1、单例模式</h2>

保证一个类仅有一个实例，并提供一个访问它的全局访问点

### 要点

- 让类自身负责保持它的唯一实例。这个类可以保证没有其他实例可以被创建，并且提供访问该实例的方法。对唯一的实例可以严格控制客户如何以及怎样访问。
  
- 多线程单例需要保证线程安全，需要对实例添加锁。

- 直接加锁每次都有lock判定，所以有了双重锁定(Double-Check Locking)。

<h2 id="2">2、工厂方法模式</h2>

定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到其子类。

### 要点

- 相对于简单工厂，将对象创建定义出抽象接口，便于抽象实例的扩展的变化，保持了简单工厂的优势？？？，在我们增加新的产品时，不需要去更改原有的产品体系和工厂类，只需要拓展新的类就可以了。对于厂来说符合开放封闭原则。
  
- 但是由于将工厂的选择判断转移到了客户端，和客户端的耦合性又大大增加了。
  
- 工厂模式的优势在于，通常设计应该从工厂方法开始，当设计者需要更多灵活性时，便会想其他创建型模式演化。当设计者在设计标准间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地。

<h2 id="3">3、抽象工厂模式</h2>

提供一个创建一系列或线管依赖对象的接口，而无需指定他们具体的类。

### 要点

- 它让具体的创建实例过程与客户端分离，客户端是他用过他们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在代码中。
  
- 抽象工厂在变更的时候虽然修改只用改变工厂类，但是工厂类多了也麻烦，和客户端的耦合大，使用简单工厂将接口统一能让代码更好的解耦内聚。可以结合简单工厂，通过依赖注入，克服简单工厂和抽象工厂的坏处，结合使用

### 使用场合

<h2 id="4">4、建造者模式</h2>

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

### 要点

- 将一个复杂对象的构建与它的表示分离，这样就可以很容易的改变一个产品的内部表示，并且使得构造代码和表示代码分开。这样对于客户来说，它无需关系产品的创建过程，只要告诉我们需要什么，就能用。实际的建造过程由指挥者(Director)封装建造过程，它隔离用户与建造过程的关联。
  
- 当需要改变一个产品的内部表示时，由于建造代码和表示代码是分离的，只需要再定义一个具体的建造者就可以了。

- 用户只用指定需要见着的类型(业务结果)，而具体的建造过程和细节(业务逻辑)就不需要知道了

### 使用场合

- 建造者模式是当创建复杂对象的算法，应该独立于该对象的组成部分，和他们的装配方式的时候的一种模式

<h2 id="5">5、原型模式</h2>

用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

### 要点

- 从一个对象再创建另一个可定制的对象，而且不需要知道任何创建的细节。

- 一般在初始化的信息不发生变化的时候，克隆是最好的解决办法，不需要知道对象创建的细节，对性能有大大的提高了。

- 建立相应数目的原型并克隆他们通常比每次使用合适状态手工实例化该类更方便些。

<br>

<h1 id="01">一、结构型型模式</h1>

对象的继承关系在编译时就定义好了，无法在运行时改变从父类继承的实现。 子类的实现与父类有非常紧密的依赖关系，以至于父类的实现中的任何变化必然会导致子类发生变化。 当要服用子类时候，如果继承的实现不适合解决问题，就要变更父类，使得可拓展性变差，最终这种依赖关系破坏了复用性。所以，在类的设计中，优先使用合成/聚合复用原则，而不是类继承。

合成/聚合复用原则：聚合表示一种弱的拥有关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；
合成则是一种强 ‘拥有’ 关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。


<h2 id ="6"> 6、适配器模式 </h2>

将一个类的接口转化为客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。

### 要点

- 通过包装一个原始对象，把源接口转换成目标接口。

### 使用场合

- 在系统的数据和行为都正确，但是接口不符时，应该使用适配器。使用一个已经存在的类，而他的接口不符合要求，或者希望创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作。适配器模式这时候就合适使用，可以让这些接口不同的类通过适配后，协同工作。

### 思考

- 适配器主要解决两个已有接口之间不匹配的问题，不需要考虑这些接口是怎样实现的，也不用考虑他们各自可能会如何演化。它不需要对两个独立的设计中任何一个进行重新设计。但是当接口不同时，首先更应该考虑重构统一接口，只有在双方都不太容易修改的时候再使用适配器模式适配

<h2 id ="7"> 7、装饰模式 </h2>

动态的给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。

### 要点

- 装饰模式通过对对象进行一层封装，利用SetComponent对对象进行包装。这样每个具体的装饰对象的实现就和如何使用这个对象分开了。每个装饰对象只关心自己的供能。而如何被添加到对象链中就让客户去调用。
- 装饰者模式，可以更加灵活、以动态、透明的方式给单个对象添加职责，并在不需要时，撤销相应的职责。
- 把类中的装饰功能从类中搬移去除，简化原有的类。 同时有效的把核心职能和装饰工能区分开了。还可以去除相关类中重复的装饰逻辑。
  
### 使用场合

- 当给系统添加一些新功能的时候，这些新的代码通常是对原有类的核心职责或主要行为的装饰。但是在主类中添加新的字段、方法、和逻辑增加了主类的复杂度，这些新的东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。 这种情况下，可以使用装饰者模式，把每个装饰的功能放在单独的类中，让这个类包装它所要装饰的对象，添加新的逻辑。然后客户端运行的时候需要使用到这个新的逻辑的时候就有选择的按序使用装饰。


### 引申和思考

- 装饰者模式，主要是针对一个类的结构，进行简化和拆分。简化类的职责，便于拓展。将装饰的实现和如何使用隔离，让客户选择如何搭配使用装饰。
  
- 装饰者更多的是在处理一件事情前的一些操作处理进行装饰划分。 比如创建角色的宠物，是不是可以套用为一个装饰？
  
- 要注意的是，装饰者模式具有顺序性。 比如加密数据 和 过滤词汇都可以是数据持久化前的装饰功能，但是如果客户先加密数据再使用过滤功能就会出现问题。 最好是保持装饰类间彼此独立。

<h2 id ="8"> 8、桥接模式 </h2>

将抽象部分与他们的实现部分分离，使得他们可以独立的变化。

### 要点

- 找出变化并封装。 将抽象中的具有变化的实现，进行分离出来，然后组合到抽象类中。这样将变化独立了出来，便于变化的拓展，同时不需要通过在继承去实现这些角度的变化。
- 
- 在设计之初就需要考虑到这一点。

### 使用场合

- 如果实现系统的继承体系中，有多角度的分类，有两个甚至多个方向的变化，那么就需要解耦这些不同方向的变化，通过对象组合的方式，把两个角色之间的继承关系改为组合的关系，从而使得可以应对各自独立的变化。 这样可以避免庞大耦合的类继承形成的结构。

### 引申和思考

- 桥接也是给另一个对象提供一定程度的间接性。但是桥接是在设计之初，就对抽象接口与它的实现部分进行桥接，让抽象与实现两者可以独立演化。
  
- 最主要的就是，优先使用对象的 合成/聚合，有助于帮你保持每个类被封装起来，并集中在单个任务上。这样类的继承能保持比较小的规模，更具有拓展性。

<h2 id ="9"> 9、组合模式 </h2>

将对象组合成树形结构以表示‘部分整体’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

### 要点

- 用户使用组合类接口与组合结构中的对象进行交互，如果接受者是一个叶节点，者直接处理请求，如果接受者是组合对象，通常将请求发送给他的子部件，并在转发请求之前或之后可能执行一些辅助操作。
  
- 可以让用户一致的使用组合结构和单个对象。 任何用到基本对象的地方都可以使用组合对象。

### 使用场合

- 当需求中是体现部分与整体层次的结构时，你希望用户可以忽略组合对象与单个对象的不用，统一的使用组合结构中的所有对象时，可以考虑使用组合模式。

### 引申和思考

<h2 id ="10"> 10、享元模式 </h2>

为运用共享技术有效的支持大量细粒度的对象。通过服用内存中已经存在的对象，降低系统创建对象实例的性能消耗。

### 要点

- 享元模式有两种状态
    - 内部状态:在享元对象内部，并且不会随环境改变而改变的共享部分，是享元对象的内部状态。对任何一个享元对象而言，内部状态的值是完全相同的。
    - 外部状态：会根据环境改变而改变的，是外部状态。是需分离出来的不可共享的，对于不同的享元对象而言，他的值可能是不同的。
- 享元模式通过共享内部状态，区分外部状态，有效隔离系统中变化部分和不变部分。
  
### 使用场合
以下情况都可以使用享元模式：
- 如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时。
- 对象的大多数状态可以外部状态。
- 系统中某个对象类型的实例较多的时候。
- 在系统设计中，对象实例进行分类后，发现真正有区别的类很少的时候

### 引申与参考

-   为了返回一个已经创建的享元，要和已经实例化的对象建立联系，可以使用对象池来操作。
-   当使用状态模式时可以配合享元模式，在不同的状态机上使用相同的对象实例。
   
<h2 id ="11"> 11、代理模式 </h2>

为其他对象提供一种代理以控制这个对象的访问。

### 要点

- 代理与外观的主要区别在于，代理对象代表一个单一对象，而外观对象代表一个子系统。
  
- 代理的客户对象无法直接访问目标的对象，由代理提供单独的目标对象的访问控制。 而外观的客户对象可以直接访问子系统中的各个对象，但通常外观对象提供对子系统各元件工能的简化的共同层次的调用接口。
  
- 代理是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个代表交涉。而适配器不需要虚构出一个代表者，只要为应付特定使用目的，将原来的类进行一些组合。

### 使用场合
 
<h2 id ="12"> 12、外观模式 </h2>

为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

### 要点

- 设计初期阶段，应该有意思的将不同的两个层分离，经典的三层架构，就需要考虑在 数据访问层 和 业务逻辑层 和 表现层 的层与层之间建立外观，这样可以为复杂的子系统提供一个简单的接口，降低耦合。

- 开发阶段：子系统往往因为不断的重构演化而变的复杂，大多数的模式使用的时候也会产生很多很小的类，给调用者带来了使用上的困难，增加外观Facade 可以提供一个简单的接口，减少他们之间的依赖。
  
- 维护遗留大型系统：在基于庞大复杂的旧系统上开发新系统的时候，通过为新系统开发一个外观Facade类，来提供设计粗糙或或高度复杂的遗留代码比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。

- 如果两个类不必彼此直接通信，那么就不要让这两个类发生直接的相互作用。如果实在需要可以通过第三者来转发调用。
  
- 让一个子系统间的通信和相互依赖关系达到最小，而具体办法就是引入一个外观对象，它为子系统提供了一个单一而简单的屏障。
  
### 思考

- 通常企业软件的三层或N层架构，层与层之间的分离其实就是外观模式的体现。
- 适配器模式：当需要使用一个现有的类，但是接口并不符合要求，考虑使用适配器模式。将一个对象包装起来改变接口。
- 外观模式：当需要简化并统一一个/一群很大的接口的时候，考虑使用外观模式。依托与子系统执行。
- 装饰模式：将一个对象包装起来，增加行为和责任。

<br>
<br>
<h1 id = "3">三、行为型模式(Part1)</h2>

<br>

<h2 id = "13"> 13、观察者模式 </h2>

定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并且被自动更新。

<h2 id = "14"> 14、模板方法模式 </h2>

定义一个操作的算法骨架，将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

### 要点

- 模板方法模式由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模板，每个从这个抽象类派生的具体类将为此模板实现新的方法。这昂所有可重复的代码都提炼到抽象类中，这也是继承的最大的好处，可以从基类免费获取一些东西。

### 使用场合

- 当看到一个以上相同的程序结构，那么就应该设法将她们统一。 
- 完全相同的代码时
- 微妙的重复出现在 表面不同，但是本质相同的 结构 或 处理步骤中，折合时候也需要将重复统一。

<h2 id = "15"> 15、命令模式 </h2>

将一个请求封装为一个对象，从而使你可以用不用的请求对客户进行参数化；可以对请求排队或记录请求日志，以及支持可撤销的操作。

### 要点

### 使用场合



### 思考和引申

- 将调用操作的对象与知道如何实现该操作的对象解耦。 在两者之间可以处理很多其他的事情。 具体怎么做可以是不用时刻指定、排列和执行亲求。实施操作 前存储状态，一边支持取消/重做的操作。

<h2 id = "16"> 16、状态模式 </h2>

允许一个对象在其内部状态改变时改变他的行为，让对象看起来似乎修改了它的类。

<h2 id = "17"> 17、责任链模式 </h2>

使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。

### 要点

- 有多个对象可以处理一个请求，哪个对象处理该请求事先并不知道，要在运行时刻自动确定，此时，最好的方法就是让请求发送者与具体处理者分离，让客户在不明确指定接收者的情况下，提交一个请求，然后由所有能处理这请求的对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。