# 《大话设计模式》全书概览

  ![](Media/1.png)
<br>
<br>

# 目录与说明

* [零、模式构成](#00)
* [一、创建型模式](#01)
    * [1、单例模式](#1)
    * [2、工厂方法](#2)
    * [3、抽象工厂方法](#3)
    * [4、建造者模式](#4)
    * [5、原型模式](#5)
* [二、结构型模式](#02)
    * [6、适配器模式](#6)
    * [7、装饰模式](#7)
    * [8、桥接模式](#8)
    * [9、组合模式](#9)
    * [10、享元模式](#10)
    * [11、代理模式](#11)
    * [12、外观模式](#12)
* [三、行为型模式(Part1)](#03)
    * [13、外观模式](#13)
    * [14、模版方法模式](#14)
    * [15、命令模式](#15)
    * [16、状态模式](#16)
    * [17、职责链模式](#17)
* [四、行为型模式(Part2)](#04)
    * [18、解释器模式](#18)
    * [19、中介者模式](#19)
    * [20、访问者模式](#20)
    * [21、策略模式](#21)
    * [22、备忘录模式](#22)
    * [23、迭代器模式](#23)
<h1 id='00'>零、模式构成</h1>


- 抽象、封装、继承、多态，是设计模式实现的基本思想和工具。

- 单一职责、开放封闭原则、依赖倒置原则、里氏代换原则、合成聚合复用原则、迪米特法则，是设计模式要达到的最终目的。
  
  抽象不应该依赖于细节，细节应该依赖于抽象

[C#练习工程-Gitee仓库地址](https://gitee.com/bambom/shejimoshi)
 <br>

正文：
  <br>
  <br>

<h1 id="01">一、创建型模式</h1>

- 内聚性：描述的是一个例程内部组成部分之间相互联系的紧密程度。 耦合性：描述的是一个例程与其他例程之间联系的紧密程度。 软件开发的目标应该是创建这样的例程： 内部完整(高内聚)，与其他例程之间联系是小巧、直接、可见、灵活的(松耦合)。
  
- 创建型模式隐藏了这些类的实例是如何被创建和放在一起的，整个系统关于这些对象所知道的是有抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建的类、类是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。

- 创建型模式抽象了实例化的过程。他们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建性模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的在运行时指定。
  
- 当一个系统应该独立于他的产品创建、构成、和表示时，应该考虑用创建型模式。

<h2 id="1">1、单例模式</h2>

保证一个类仅有一个实例，并提供一个访问它的全局访问点

### 要点

- 让类自身负责保持它的唯一实例。这个类可以保证没有其他实例可以被创建，并且提供访问该实例的方法。对唯一的实例可以严格控制客户如何以及怎样访问。
  
- 多线程单例需要保证线程安全，需要对实例添加锁。

- 直接加锁每次都有lock判定，所以有了双重锁定(Double-Check Locking)。

<h2 id="2">2、工厂方法模式</h2>

定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到其子类。

### 要点

- 相对于简单工厂，将对象创建定义出抽象接口，便于抽象实例的扩展的变化，保持了简单工厂的优势？？？，在我们增加新的产品时，不需要去更改原有的产品体系和工厂类，只需要拓展新的类就可以了。对于厂来说符合开放封闭原则。
  
- 但是由于将工厂的选择判断转移到了客户端，和客户端的耦合性又大大增加了。
  
- 工厂模式的优势在于，通常设计应该从工厂方法开始，当设计者需要更多灵活性时，便会想其他创建型模式演化。当设计者在设计标准间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地。

<h2 id="3">3、抽象工厂模式</h2>

提供一个创建一系列或线管依赖对象的接口，而无需指定他们具体的类。

### 要点

- 它让具体的创建实例过程与客户端分离，客户端是他用过他们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在代码中。
  
- 抽象工厂在变更的时候虽然修改只用改变工厂类，但是工厂类多了也麻烦，和客户端的耦合大，使用简单工厂将接口统一能让代码更好的解耦内聚。可以结合简单工厂，通过依赖注入，克服简单工厂和抽象工厂的坏处，结合使用

### 使用场合

<h2 id="4">4、建造者模式</h2>

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

### 要点

- 将一个复杂对象的构建与它的表示分离，这样就可以很容易的改变一个产品的内部表示，并且使得构造代码和表示代码分开。这样对于客户来说，它无需关系产品的创建过程，只要告诉我们需要什么，就能用。实际的建造过程由指挥者(Director)封装建造过程，它隔离用户与建造过程的关联。
  
- 当需要改变一个产品的内部表示时，由于建造代码和表示代码是分离的，只需要再定义一个具体的建造者就可以了。

- 用户只用指定需要见着的类型(业务结果)，而具体的建造过程和细节(业务逻辑)就不需要知道了

### 使用场合

- 建造者模式是当创建复杂对象的算法，应该独立于该对象的组成部分，和他们的装配方式的时候的一种模式

<h2 id="5">5、原型模式</h2>

用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

### 要点

- 从一个对象再创建另一个可定制的对象，而且不需要知道任何创建的细节。

-一般在初始化的信息不发生变化的时候，克隆是最好的解决办法，不需要知道对象创建的细节，对性能有大大的提高了。

- 建立相应数目的原型并克隆他们通常比每次使用合适状态手工实例化该类更方便些。

